# 완전검색 & 그리디 2

## 부분집합

- 집합에 포함된 원소들을 선택하는 것이다.
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분집합 찾는 것이다.
- N개의 원소를 포함한 집합
  - 예 : 배낭 짐싸기
- 자기 자신과 공집합 포함한 모든 부분집합의 개수는 2^n개
- 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

### 단순하게 모든 부분집합 생성하는 방법

```python
for i1 in a:
  bit[0]
  for i2 in a:
    bit[1]
    for i3 in a:
      bit[2]
      for i4 in a:
        bit[4]
        print(arr)
```

### 바이너리 카운팅을 포함한 사전적 순서

- 부분집합을 생성하기 위한 가장 자연스러운 방법이다
- 바이너리 카운팅은 사전적 순서로 생성하기 위한 가장 간단한 방법이다.
  - 원소 수에 해당하는 N개의 비트열을 이용한다
  - n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미
  ```python
  arr = [3, 6, 7, 1, 5, 4]
  n = len(arr)
  for i in range(0, (1<<n)): # 부분집합의 개수
    for j in range(0, n):
      if i & (1<<j): # i의 j번째 비트가 1이면 j번째 원소 출력
        print('%d'%arr[j], end='')
      print()
  ```

## 조합

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합이라고 부른다

### 재귀 호출을 이용한 조합 생성 알고리즘

```python
an[]: n개의 원소를 가지고 있는 배열
tr[]: r개의 크기의 배열, 조합이 임시 저장될 배열

comb(n, r)
  if(r == 0)
    print_arr()
  else
    if (n < r)
      return
    else
      tr[r-1] = an[n-1]
      comb(n-1, r-1)
      comb(n-1, r)
```

### 10개의 원소 중 3개를 고르는 조합

```python
for i in range(N-2): # j, k로 선택될 원소를 남김
  for j in range(i+1, N-1) # k로 선택될원소를 남김
    for k in range(j+1, N):
      print(i, j, k)
```

### n개의 원소 중 r개를 고르는 조합(재귀)

```python
def nCr(n, r, s): # n개에서 r개를 고르는 조합, s 선택할 수 있는 구간의 시작
  if r == 0:
    print(*comb)
  else:
    for i in range(s, n-r+1):
      comb[r-1] = A[i]
      nCr(n, r-1, i+1)
```

## 그리디 알고리즘

- 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제
- 반드시 최적해는 아니다.
  - 예: 배낭 짐싸기 문제

### 활동 선택 문제

- 탐욕 기법을 적용한 반복 알고리즘
  - 종료 시간이 빠른 순서로 활동들을 정렬한다(sort)
  - 첫번째 활동을 선택하고 선택한 활동의 종료 시간보다 빠른 시작 시간을 가지는 활동을 모두 제거한다
  - 남은 활동들에 대해 앞의 과정을 반복한다

- 재귀 알고리즘 이용
```python
# A: 정렬된 활동들의 집합
# S: 선택된 활동(회의)들 집합
# 시작시간, f: 종료시간, 0<= i <= n+1
# 종료시간 가장 빠른 활동 선택

```
### 탐욕 기법과 동적 계획법
- 탐욕 기법 : 매 단계에서 가장 좋아 보이는 것을 선택
- 동적 계획법 : 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 한다

