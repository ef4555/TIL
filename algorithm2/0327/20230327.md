# 완전검색과 그리디
## 반복과 재귀
- 반복과 재귀는 유사한 작업을 수행할 수 있다.
- 재귀 호출은 반복적인 스택의 사용으로 메모리 및 속도에서 성능저하가 발생
- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다
  - 재귀 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연선 필요

## 완전검색기법
- 우선 완전 검색으로 접근하여 해답을 도출한 후 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직

## 순열
- 서로 다른 것들 중 몇 개를 뽑아서 한줄로 나열하는 것(순서 상관 있다)
- 단순하게 모든 순열 생성하는 함수
- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다.
  - 예: TSP(Traveling Saleman Problem)
```python
for i1 in a:
  for i2 in a:
    if i1 != i2:
      for i3 in a:
        if i3 != i1 and i3 != i2
          print(i1, i2, i3)
```
- 재귀로 순열 생성
```python
perm(i, k)
  if i == k:
    print('원하는 작업 수행')
  else:
    for j in range(i, k):
      p[i], p[j] = p[j], p[i] # 계속 옆에꺼 옆옆에꺼 ... 자리 바꿈
      perm(i+1, k) # 다음 자리 탐색
      p[i], p[j] = p[i], p[j]
```

```python
perm(i, k)
  if i == k:
    print('원하는 작업 수행')
  else:
    for j in range(0, k): # 사용하지 않은 숫자를
      if used[j] == 0: # used에서 순서대로 검색
        p[i] = A[j]
        used[j] = 1 # j번 자리 숫자 사용으로 표시
        perm(i+1, k)
        used[j] = 0 # j번 자리 숫자를 다른 자리에서 쓸 수 있게

A = [1,2,3]
p = [0]*3
used = [0]*3
perm(0,3)
```
