# Vue Router

## UX/UI
- UX
  - 유저와 가장 가까이에 있는 분야, 데이터를 기반으로 유저를 조사하고 분석해서 개발자, 디자이너가 이해할 수 있게 소통
  - 유저가 느끼는 느낌, 태도 그리고 행동을 디자인
  - 좋은 UX를 설계하기 위해서는
    - 사람들의 마음과 생각을 이해하고 정리해서 우리 제품에 녹여내는 과정이 필요
    - 유저 리서치, 데이터 설계 및 정제, 유저 시나리오, 프로토타입 설계 등이 필요

- UI
  - 유저에게 보여지는 화면을 디자인
  - UX를 고려한 디자인을 반영, 이 과정에서 기능 개선 혹은 추가가 필요한 경우 프론트엔드 개발자와 많이 소통

- interface
  - 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점
    - 즉, 사용자가 기기를 쉽게 동작 시키는데 도움을 주는 시스템
  - 생활 속 인터페이스 예시
    - CLI나 GUI를 사용해서 컴퓨터를 동작


- 좋은 UI를 설계하기 위해ㅓ는 
  - 예쁜 디자인 즉, 심미적인 부분만 중요하다기보다는 사용자가 보다 쉽고 편리하게 사용할 수 있도록 하는 부분까지 고려되어야 함
  - 통일된 디자인을 위한 디자인 시스템, 소통을 위한 중간 산출물, 프로토타입 등이 필요
  - UI 디자인에 있어 가장 중요한 것은 협업

- 디자이너와 기획자 그리고 개발자
  - 많은 회사에서 UX/UI 디자인을 함께하는 디자이너를 채용하거나 UX 는 기획자 UI는 디자이너의 역할로 채용하기도 함
  - UX 직무
    - 구글 : 사용자의 경험을 이해하기 위한 통계 모델을 설계
    - MS : 리서치를 계획하고 사용자에 대한 지표를 정의
    - Meta : 정성적인 방법과 정량적인 방법을 사용해서 사용자 조사를 실시
  - UI 직무
    - 구글 : 다양한 디자인 프로토타이핑 툴을 사용해서 개발 가이드를 제동
    - MS : 시각 디자인을 고려해서 체계적인 디자인 컨셉을 보여줌
    - Meta : 제품을 이해하고 더 나은 UI Flow와 사용자 경험을 디자인
  - 개발자는 단순히 기능 개발만 하는 사람이 아니며 제품에 대해 고민하고 소통하는 능력이 반드시 필요
  - 즉, 다양한 분야와의 협업이 필수적이기에 기본적인 UX/ UI에 대한 이해가 있어야 함


### prototyping
- 애플리케이션의 프로토타입을 만드는 것
- 예전에는 Sketch라는 툴이 많이 사용되었지만 현재에는 Figma라는 툴이 약 70%의 시장 점유율을 보이고 있음
  - figma는 웹 기반 환경에서 동작, 매우 가벼운 환경에서 실행 가능, 모든 작업내용이 웹에 저장
  - 실시간으로 팀원들이 협업할 수 있는 기능을 제공
  - 직관적이고 다양한 디자인 툴을 제공
  - figma 사용자들이 만든 다양한 플러그인이 존재
  - 대부분의 기능이 무료
  - 성능의 희생을 일부 감수하고 웹 기반으로 원활한 협업이 이루어지도록 함

### 프로젝트를 시작하기 전에
- 개발부터 시작하지 말고 반드시 충분한 기획을 거칠 것
- 우리가 완성하고자 하는 대략적인 모습을 그려보는 과정이 필요(프로토타이핑)
- 이러한 과정을 통해서 기획에서 빠진 화면이나 API 등을 확인할 수 있음
- 설계와 계획이 끝난 후 개발을 시작해야 체계적인 진행이 가능함

## Routing
- 네트워크에서 경로를 선택하는 프로세스
- 웹 서비스에서의 라우팅
  - 유저가 방문한 URL에 대해 적절한 결과를 응답하는 것
  - 예시 : ./articles/index/에 접근하면 articles의 index에 대한 결과를 보내줌

### Routing in SSR
- server가 모든 라우팅을 통제
- URL로 요청이 들어오면 응답으로 완성된 HTML을 제공
- 결론적으로 Routing(URL)에 대한 결정권을 서버가 가짐 

### Routing in SPA/CSR
- 서버는 하나의 HTML 만을 제공
- 이후에 모든 동작은 하나의 HTML 문서 위에서 자바스크립트 코드를 활용
  - DOM을 그리는데 필요한 추가적인 데이터가 있다면 axios와 같은 AJAX 요청을 보낼 수 있는 도구를 활용하여 데이터를 가져오고 처리
- 즉, 하나의 URL만 가질 수 있음

### Why routing
- 그럼 동작에 따라 URL이 반드시 바뀌어야 하나?
  - 그렇지는 않다. 단, 유저의 사용성 관점에서는 필요함

- Routing이 없다면 유저가 URL를 통한 페이지의 변화를 감지할 수가 없음
  - 페이지가 무엇을 렌더링 중인지에 대한 상태를 알 수 없음
    - 새로고침 시 처음 페이지로 돌아감
    - 링크를 공유할 시 처음 페이지만 공유 가능
  - **브라우저의 뒤로 가기 기능을 사용할 수 없음**


## Vue Router
- Vue의 공식 라우터
- SPA 상에서 라우팅을 쉽게 개발할 수 있는 기능을 제공
- 라우트에 컴포넌트를 매핑한 후 어떤 URL에서 렌더링 할 지 알려줌
  - 즉, SPA를 MPA처럼 URL을 이동하면서 사용 가능
  - SPA의 단점 중 하나인 URL이 변경되지 않는다 를 해결
- MPA
  - 여러 개의 페이지로 구성된 애플리케이션
  - SSR 방식으로 렌더링

```
vue router 시작:
$ vue create vue-router-app
$ cd vue-router-app
$ vue add router
history mode 사용 여부 => Yes
```
- history mode
  - 브라우저의 history API를 활용한 방식
    - 새로고침 없이 URL 기록을 남길 수 있음
  - 우리에게 익숙한 URL 구조로 사용 가능

- history mode를 사용하지 않으면
  - Default 값인 hash mode로 설정됨(#를 통해 URL을 구분하는 방식)
    - http://localhos:8080#index

### vue router 시작하기
1. App.vue에 router-link 요소 및 router-view가 추가됨
2. router/index.js 생성
3. views 폴더 생성


#### router-link
- a태그와 비슷한 기능 - URL을 이동시킴
  - routers에 등록된 컴포넌트와 매핑됨
  - 히스토리 모드에서 router-link는 클릭 이벤트를 차단하여 a태그와 달리 브라우저가 페이지를 다시 로드하지 않도록 함
- 목표 경로는 to 속성으로 지정됨
- 기능에 맞게 HTML에서 a 태그로 rendering 되지만, 필요에 따라 다른 태그로 바꿀 수 있음

#### router-view
- 주어진 URL에 대해 일치하는 컴포넌트를 렌더링하는 컴포넌트
- 실제 component가 DOM에 부착되어 보이는 자리를 읨;ㅣ
- router-link를 클릭하면 routes에 매핑된 컴포넌트를 렌더링

- Djangod에서의 block tag와 비스삼
  - App.vue는 base.html의 역할
  - router-view는 block 태그로 감싼 부분

#### src/router/index.js
- 라우터에 관련된 정보 및 설정이 작성 되는 곳
- django에서의 urls.py에 해당
- routes에 URL과 컴포넌트를 매핑

#### src/Views
- router-view에 들어갈 컴포넌트 작성
- 기존에 컴포넌트를 작성하던 곳은 components 폴더 뿐이었지만 이제 두 폴더로 나뉘어짐
- 각 폴더 안의 .vue 파일들이 기능적으로 다른 것은 아님
  
- 폴더 별 컴포넌트 배치
- views
  - routes에 매핑되는 컴포넌트
  - <router-view>의 위치에 렌더링 되는 컴포넌트를 모아두는 폴더
  - 다른 컴포넌트와 구분하기 위해 view로 끝나도록 만드는 것을 권장
  - 예 : App 컴포넌트 내부의 AboutView & HomeView


#### Dynamic Route Matching
- 동적 인자 전달
  - URL의 특정 값을 변수처럼 사용할 수 있음

- HellowView.vue 작성 및 route 추가
- route를 추가할 때 동적 인자를 명시

#### lazy-loading
- 모든 파일을 한 번에 로드하려고 하면 모든 걸 다 읽는 시간이 매우 오래 걸림
- 미리 로드를 하지 않고 특정 라우트에 방문할 때 매핑된 컴포넌트의 코드를 로드하는 방식을 활용할 수 있음
  - 모든 파일을 한번에 로드하지 않아도 되기 때문에 최초에 로드하는 시간이 빨라짐
  - 당장 사용하지 않을 컴포넌트는 먼저 로드하지 않는 것이 핵심
  - 