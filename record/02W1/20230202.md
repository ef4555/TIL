# 정렬

## 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 알고리즘
- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
-시간복잡도
    -O(n+k) : n은 리스트 길이, k는 정수의 최댓값

```
data = [0, 4, 1, 3, 1, 2, 4, 1]
counts = [1, 3, 1, 1, 2] # count[i]+count[i-1]
counts = [1, 4, 5, 6, 8] # 누적해서 더해준다.
# 원본 데이터와 같은 크기의 tmp 만듦
data = [0, 4, 1, 3, 1, 2, 4, 1]
# 7인 인덱스부터 0까지 앞으로 가면서 그 숫자가 있는 counts 자리값을 하나씩 감소
```

```
C = [0]* (k+1)

for i in range(1, len(A)):
C[A[i]] += 1

for i in range(1, len(A)):
C[i] += C[i-1]

for i in range(len(B)-1, -1, -1):
C[[i]] -= 1
B[C[A[i]]] = A[i]
```

## 완전 검색
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- Brute Force, generate and test 기법
- 모든 경우의 수를 테스트 한 후, 최종 해법을 도출
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
- 수행속도는 느리지만 해답을 찾아낼 수 있다.
- 완전 검색으로 일단 시작하여 답을 도출한 후 성능 개선을 위해 다른 알고리즘을 사용해보는것이 좋다

### baby-gin 게임
- 임의의 카드 6장, 3장이 연속적이면 run, 3장이 동일하면 triplet
- run과 triplet 둘 다 있으면 baby-gin

### 완전 검색을 통한 baby-gin 접근
- 6개의 숫자로 만들 수 있는 모든 숫자를 나열해서 앞의 3자리와 뒤의 3자리를 잘라 run, triplete 여부를 테스트하고 판단

#### 순열 생성
- 순열 :  서로 다른 것 중 몇 개를 뽑아서 한 줄로 나열하는것
```
# {1, 2, 3}을 포함하는 모든 순열을 행성하는 함수 (3개 고정일때)

for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```

### 탐욕(greedy) 알고리즘
- 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 greedy 접근이 된다 
#### 탐욕 알고리즘의 동작 과정
1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.
2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인한다.
곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1.의 해 선택부터 다시 시작한다. 

#### 탐욕 알고리즘의 예
- 거스름돈 줄이기
    - 지폐와 거스름돈을 최소한으로 

- 해 선택 : 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어드므로, 현재 고를 수 있는 가장 큰 단위의 동전을 골라 거스름돈에 추가

- 실행 가능성 검사 : 거스름돈이 현재 내드려야할 액수를 초과했는지 확인하고 초과 시에는 마지막에 추가한 동전을 거스틈돈에서 빼고 1로 돌아가서 한단위 더 작은 동전을 추가

- 해 검사 : 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내 드려야하는 액수와 일치해야 한다. 거스름돈을 확인해서 액수에 모자라면 1로 돌아가서 추가할 동전을 고른다.
#### 베이비-진을 완전검색이 아닌 방법으로 풀면
- 6개의 숫자는 6개의 정수 값으로 입력된다
- counts 배열의 각 원소를 체크하여 run과 triplet 및 baby-gin 여부 판단.

```
num = 456789 # 베이비 진 확인할 6자리 수
c = [0]*12 # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트 뒤의 두 자리를 더 활용하기 위해 10이 아니라 12
for i in range(6):  # 중요중요
    c[num % 10] += 1
    num //= 10 
i = 0
tri = run = 0
while i < 10:
    if c[i] >= 3 : # triplete 조사 후 데이터 삭제
        c[i] -= 3
        tri += 1
        countinue
    if c[i] >= 1 and c[i+1] >= and c[i+2] >= 1 : # run 조사 후 데이터 삭제
        c[i] -= 1
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1
if run + tri == 2 : print("baby Gin")
else : print("Lose")
```

