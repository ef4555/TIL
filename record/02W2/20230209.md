# 문자열 2
## 문자열 숫자를 정수로 변환하기
- C언어는 atoi()함수를 제공한다 역함수로는 itoa()함수가 있다
- 자바에서는 숫자 클래스의 parse 메소드를 제공한다
- 파이썬에서는 숫자와 문자변환 함수를 제공한다. 

```python
# int 함수 구현하기
def atoi(s):
    i = 0
    for x in s:
        i = i *10 + ord(x)-ord('0') 
    return i
```

## 패턴 매칭에 사용되는 알고리즘들
- 고시직한 패턴 검색 알고리즘
- 카프-라빈 알고리즘
- KMP 알고리즘
- 보이어-무어 알고리즘

### 고지식한 알고리즘(Brute Force)
- 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일히 비교하는 방식으로 동작

```python
p = 'is'
t = 'This is a book'
M = len(p) # 찾을 패턴의 길이
N = len(t) # 전체 텍스트의 길이
def Brute(p, t):
    i = 0 # 전체 텍스트의 인덱스
    j = 0 # 찾을 패턴의 인덱스 
    while j < M and i < N:
        if t[i] != p[j]: # 다를때는
            i = i-j # i와 j가 같은 속도로 증가하므로 0이 되고 찾는 인덱스 +1부터 또 탐색
            j = -1 # 뒤에 +1이 있으므로 찾을 패턴 인덱스 다시 0부터 시작
        i = i + 1   # 일단 조건과 상관없이 앞으로 가면서 탐색하기
        j = j + 1   # 일단 조건과 상관없이 앞으로 가면서 탐색하기
    if j == M  : return i - M # j = M 이면 찾을 패턴 전체 돌았다는 이야기. 검색 성공
    else :  return -1 # 검색 실패 

```


```python 
p = 'is'
t = 'This is a book'
M = len(p) # 찾을 패턴의 길이
N = len(t) # 전체 텍스트의 길이
def Brute(p, t):
    i = 0 # 전체 텍스트의 인덱스
    j = 0 # 찾을 패턴의 인덱스 
    while j < M and i < N:
        if t[i] == p[j]: # 같을때 전진 
            i += 1
            j += 1
        i = i - j + 1  # 다르면 전체 패턴 인덱스 한 칸 전진
        j = 0  # 비교할 문자열 다시 0부터 시작
    if j == M  : return i - M # j = M 이면 찾을 패턴 전체 돌았다는 이야기. 검색 성공
    else :  return -1 # 검색 실패 
```


```python
def bf(p, t, N, M):
    for i in range(N-M+1): # 끝에 어디까지 가야하는지 파악하는게 중요하다.
        for j in range(M): # M 비교할 문자열의 길이
            if t[i+j] != p[j]: # i+j하면 N-M+M+1로 범위 되어 전체 문자열 끝까지 도달
                break
            else:
                return i
    return -1
```

- 고지식한 패턴 검색 알고리즘의 시간 복잡도
    - 최악의 경우 텍스트의 모든 위치에서 패턴을 비교해야 함. 시간 복잡도 : O(MN)
        - 길이가 10000인 문자열에서 길이가 80인 패턴을 찾는다고 할 때 최악의 경우 10000 * 80 번의 비교
    - 비교 횟수를 줄일 방법은?

### KMP 알고리즘
- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
- 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
    - next[M] : 불일치가 발생했을 경우 이동할 다음 위치 
- 시간 복잡도 : O(M+N)
- 접두사와 접미사 사이 일치하는 최대 길이를 탐색하는것
    - 반복되는 패턴 : **abc**d**abc**ef 
    - 중개 테이블 만듦 [0,0,0,1,2,3,0,0]
    - i와 j 인덱스
    - j = 0 i = 1로 초기화

    
```python
# T : 타겟
# P : 패턴
# 브루트 포스를 하기 전 전처리를 한다는 개념이 KMP 알고리즘
# lps : longest prefix suffix
def pre_process(p):
    lps = [0] * len(p) # 중계 테이블
    # lps를 만들기 위해 패턴 인덱스
    j = 0
    # 처음부터 끝까지 순회
    for i in range(1, len(p)):
        # 패턴 발견
        if p[i] == p[j]:
            lps[i] = j +1
            j += 1
    
        # 다르다면 j 인덱스 초기화 => **패턴**의 가장 처음부터 다시 인식하도록
        else:
            j = 0
            if p[i] == j+ 1:
                lps[i] = j +1
                j += 1
    return lps

# 브루트 포스를 한 다음 
```


### 보이어-무어 알고리즘
- 오른쪽에서 왼쪽으로 비교
- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
- 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동걸이는 무려 패턴의 길이만큼이 된다. 
- 보이어 무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다.
    - 발상의 전환 : 패턴의 오른쪽부터 비교한다. 

## 문자열 암호화 
### 시저암호
- 줄리어스 시저가 사용했다고 하는 암호
- 알파벳을 일정한 문자 수만큼 [평행이동]시킴으로써 암호화
- 1씩 이동시켜보면서 해독하면 해독 가능

### 단일 치환 암호
- 문자 변환표를 이용하여 암호화
- 복호화 하기 위해서는 모든 키의 조합이 필요하다
- 단일 치환 암호 키의 총 수는 26!, 1초에 10억개의 키를 적용해도 모든 키를 조사하는데 120억년 걸림
- 문자 변환표가 알려지면 바로 암호 해독됨

### bit 열의 암호화
- 배타적 논리합 연산(exclusive-or) 사용
|x|XOR|y|
|-|-|-|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

- 암호화
|평문|1|0|0|1|1|0|0|0|
|-|-|-|
|키|1|1|0|0|0|1|1|1|
|암호문|0|1|0|1|1|1|1|1|

- 해독
|암호문|0|1|0|1|1|1|1|1|
|-|-|-|
|키|1|1|0|0|0|1|1|1|
|평문|1|0|0|1|1|0|0|0|

## 문자열 압축
- 같은 값이 몇 번 반복되는가를 나타냄으로써 압축
- 이 방법은 이미지 파일 포맷 중 BMP 파일의 압축 방법이다




