# 문자열

## 문자열
### 컴퓨터에서의 문자 표현
#### 문자의 저장과 아스키
- 글자 A를 메모리에 저장하는 방법에 대해서 알아보자
- 메모리는 숫자만을 저장할 수 있기 때문에 글자 모양 그대로 저장하는 방법이 아니라 각 문자에 대해서 대응되는 숫자를 정해놓고 이것을 메모리에 저장하는 방법이 사용될 것이다
- 메모리에 8비트 = 1바이트 단위로 저장되어 있다.
    - 1바이트는 16진수 두자리로 표현

- 파이썬이 아닌 다른 언어는 내가 문자열을 사용한다고 하면 각 변수가 몇 바이트 단위인지 지정해주어야 한다(귀찮지만 메모리에 접근하는 속도가 매우 빠름)
    - 파이썬은 알아서 단위를 정해준다.

- 영어는 대소문자 합쳐서 52이므로 6비트(64가지)면 모두 표현 가능하다. 이를 코드 체계라고 한다. 
- 원래 각자 지정해놓은 코드가 있었으나 네트워크가 발전하면서 혼동을 피하기 위해 1967년 미국에서 아스키 코드라는 문자 인코딩 표준이 제정되었다.
- 아스키 코드는 7bit인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력가능한 문자들로 이루어져 있다. 

#### 확장 아스키
- 표준 문자 이외의 악센트 문자, 도형문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다
- 확장 아스키는 8bit를 모두 사용하므로써 추가적인 문자를 표현 가능
- 컴퓨터 생산자와 소프트웨어 개발자가 여러 가지 다양한 문자에 할당 할 수 있도록 하고 있다. 이렇게 할당된 확장 부호는 표준 아스키와 같이 서로 다른 프로그램이나 컴퓨터 사이에 교환되지 못한다
- 그러므로 표준 아스키는 마이크로컴퓨터 하드웨어 및 소프트웨어 사이에서 세계적으로 통용되는 데 비해 확장 아스키는 프로그램이나 컴퓨터 또는 프린터가 그것을 해독할 수 있도록 설계되어 있어야만 올바로 해독 가능

### 유니코드
- 오늘날 대부분의 컴퓨터는 문자를 읽고 쓰는데 아스키 형식을 사용한다
- 컴퓨터가 발전하면서 미국 뿐 아니라 다른 나라에서도 컴퓨터가 발전했으며 자국의 문자를 표현하기 위해서 코드체계를 만들어 사용하게 되었다.
- 그러다가 전 세계 다국어 처리를 위해 유니코드라는 표준을 마련했다.
- 유니코드도 다시 Character Set으로 분류된다
    - UCS-2(Universal Character Set 2)
    - UCS-4(Unversal Character Set 4)
    - 유니코드를 저장하는 변수의 크기를 정의
    - 그러나 바이트 순서에 대해서는 표준화 하지 못했음
        - big-endian, little-endian
        - 1바이트가 16진수 두 개로 나눠지는데 앞에서부터 읽을건지 뒤에서부터 읽을건지의 문제
        - 지금은 little-endian이 주류

    - 다시말해 파일을 인식 시 이 파일이 UCS-2인지 UCS-4인지 각 경우를 구분해서 모두 다르게 구현해야 하는 문제 발생
    - 그래서 유니 코드의 적당한 외부 인코딩이 필요하게 되었다. 
 #### 유니코드 인코딩
 - UTF-8(in Web)
    - MIN :8bit, MAX: 32bit(1 Byte*4)
- UTF-16(in windows, java)
    - MIN :16bit, MAX: 32bit(2 Byte*2)
- UTF-32(in unix)
    - MIN :32bit, MAX: 32bit(4 Byte*1)

#### python 인코딩
- 2.x 버전 : 아스키가 기본, coding: utf-8 -*- (첫 줄에 명시)
- 3.x 버전 - 유니코드 UTF-8 생략 가능
- 다른 인코딩 방식으로 처리 시 첫줄에 작성하는 위 항목에 원하는 인코딩 방식을 지정해주면 됨

### java에서 string 클래스에 대한 메모리 배치 예
- java.lang.String 클래스에는 기본적인 객체 메타 데이터 외에 해쉬값, 문자열의 길이, 문자열의 시작점, 실제 문자열 배열에 대한 참조
### C언어에서의 문자열 처리
- 문자열은 문자들의 배열 형태로 구현된 응용 자료형
- 문자배열에 문자열을 저장할 때는 항상 마지막에 끝을 표시하는 널문자를 넣어주어야 한다.


### 참고
```
s1 = list(input)
s2 = input()
```

strlen()함수 만들어보기
def strlen(a): # \0를 만나면 \0을 제외한 글자수를 리턴

```python
def strlen(a):
    i = 0
    while a[i] != '\0':
        i += 1
    return i

a = ['a'. 'b', 'c', '\0']
print(strlen(a))
```


### 파이썬에서의 문자열 처리
- char 타입이 없음
- 텍스트 데이터의 취급 방법이 통일되어있다.
- 문자열은 시퀸스 자료형으로 분류디고, 시퀸스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있음
- replce(), split(), isalpha(), find()
- 문자열은 튜플과 같이 요소값을 변경할 수 없음(immutable)

### C와 자바의 string 처리의 기본 차이점
- c는 아스키로 저장 (몇 바이트나 사용했는지)
- 자바는 유니코드(UTF16, 2Byte)로 저장
- 파이썬은 유니코드(UTF8)로 저장

### 문자열 뒤집기
- 자기 문자열에서 뒤집는 방법이 있고, 새로운 빈 문자열을 만들어 소스의 뒤에서부터 읽어서 타겟에 쓰는 방법이 있다
- 자기 문자열을 이용할 경우에는 swap을 위한 임시 변수가 필요하며 반복 수행을 문자열 길이의 반만을 수행해야 한다
    - 문자열 길이 9, 9/2=4.5니까 4회 반복

#### 파이썬에서 문자열 뒤집기
- s = s[::-1]
- s = 'abcd'
- s = list(a)
- s.reverse()
- s = ''.join(s)

### 문자열 비교
- c에서는 strcmp() 함수를 제공한다.
- 자바에서는 equals() 메서드를 제공한다
- 파이썬에서는 == 연산자와 is 연산자를 제공한다.
    -    == 연산자는 내부적으로 특수 메서드 __eq__()를 호출

    
``` python
s1 = 'abc'
s2 = 'abc'
s3 = 'def'
s4 = s1
s5 = s1[:2] + 'c'
print(s1 == s2) # True
print(s1 is s2) # True, 문자열은 불변이기때문에 같은 곳을 참조하게 됨
print(s1 == s5) # True
print(s1 is s5) # False
print(s5)

# == 은 내용물을 비교, is는 참조하는 주소까지 비교
```