# 데이터 구조

## 어떤 자료를 어떤 구조로 다뤄야 하는가
- 추상화 : 현실세계에 있는것을 컴퓨터 언어로 표현하기 위해 존재
- 정답은 없지만 자료를 편하게 다룰수 있는 자료구조를 선택하는 것이 편하다.


## set
- 중복되는 요소가 없이 순서에 상관없는 데이터들의 묶음
    - 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
    - 순서가 없기 때문에 인덱스를 이용한 접근 불가능
    - 순서가 없기 때문에 print 할때마다 다르게 출력된다.
- 수학에서의 집합을 표현한 컨테이너
    - 중복 연산이 가능(여집합을 표현하는 연산자는 별도로 존재 X)
    - 중복된 값이 존재하지 않음
- 담고 있는 요소를 삽입 변경, 삭제 가능 => 가변 자료형(mutable)

## 딕셔너리
- 키와 값 쌍으로 이뤄진 자료형 (파이썬 3.7부터는 ordered)
- 딕셔너리의 키
    - 키는 변경 불가능한 데이터만 활용 가능
        - string, integer, float, boolean, tuple, range
- 각 키의 값 : 어떠한 형태도 상관없음
- 딕셔너리 조회 시 get 메서드를 이용하면 그 키가 있다는 확신이 없어도 값을 가져와서 판별할 수 있음
- get은 keyerror가 발생하지 않으며 default 값을 설정할 수 있음
- pop : 키가 딕셔너리에 있으면 제거하고 반환, 그렇지 않으면 default반환, default값 없으면 키에러

## 얕은 복사와 깊은 복사(shallow copy & deep copy)
- 할당
    - 대입 연산자(=) : 대입연산자를 통한 복사는 해당 객체에 대한 객체 참조를 복사
        - 해당 주소의 일부 값을 변경하는 경우, 이를 참조하는 모든 변수에 영향
- 얕은 복사
    - slice 연산자 활용하면 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소)
    - 복사하는 리스트의 원소가 주소를 참조하는 경우 : 얕은 복사의 성질 갖고 있음, 참조하는 리스트까지 복사가 되지 않는다. 단지 그 주소만 참조하게 되는 것 
- 깊은 복사
```
import copy
a = [1, 2, ['a', 'b']]
b = copy.deepcopy(a)
print(a, b) # [1, 2, ['a', 'b']] [1, 2, ['a', 'b']]
b[2][0] = 0
print(a, b) # [1, 2, ['a', 'b']] [1, 2, [0, 'b']]
```

- 리스트를 복사하고 싶은 욕망이 든다면 
    - 무조건 print를 찍어볼 것! (혹은 디버깅 툴로 리스트 변화를 확인할 것)
    - 모두 copy.deepcopy()를 한다면 컴퓨터의 메모리 용량이 너무 증가하게 되어버린다. 


```
a=257
b=257
d = 'hello'
c = 'hello'

print(id(a))
print(id(b))

# is vs == 
# is는 주소까지 같아야, ==는 값만 같으면 True
# 그러나 어느정도 작은 같은 숫자, 20자 이하 같은 문자열은 같은 주소 할당하게 파이썬에서 자동으로 설정
```
- 알고리즘 공부 시 변화하고싶은 값과 남겨두고 싶은 값을 다룰 때 얕복 깊복 개념 이해해야함

## 복습
1. 단순 복사(할당)
    - 완전히 동일한 메모리 주소에 담긴 객체를 가리킨다. 
2. 얕은 복사()
    - 해당 객체의 주소만을 복사
    - 객체 안의 객체, 내부 객체는 원본과 동일한 주소를 가리키는 객체
3. 깊은 복사()
    - 새로운 자료공간(메모리 공간)을 갖는다
    - 객체안의 객체, 내부 객체들까지도 모두 Copy

## import module
- 장점 : import에 대한 유지보수비용(휴먼리소스) 감소
    - import random
        - 모듈.함수 => DRY원칙, 모듈 반복도 원칙에 어긋남
## import from module import 메소드
- 장점
    - 모듈 안에 있는 메소드를 사용하기 위한 타이핑이 줄어든다
    - 모듈에서 특정한 부분만 해당 스크립트에서 접근 가능하도록 제어
- 단점
    - 모듈에서 새로운 항목을 추가하려면, import문을 update해야한다.
    - random 'shuffle()' Vs. random.shuffle()

## 함수를 만들 때
```
def func1(param1,/,param2) # positional|keyword
/ 앞에 있는 매개변수는 무조건 포지셔널 뒤에 있는건 무조건 키워드
```
## 처음부터 람다로 구현하지 말고 구현한 함수를 람다로 가독성을 올리는것