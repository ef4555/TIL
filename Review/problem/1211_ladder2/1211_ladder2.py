
'''
#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 도착하게 되는 출발점의 x좌표를 출력한다.

[출력]

총 10개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며, 바로 다음 줄에 테스트 케이스가 주어진다.

[입력]

한 막대에서 출발한 가로선이 다른 막대를 가로질러서 연속하여 이어지는 경우는 없다.

[제약사항]

<그림 2> 테스트케이스에 의해 생성되는 실제 사다리의 모습


아래 <그림 2>와 같은 100 x 100 크기의 2차원 배열로 주어진 사다리에 대해서, 모든 출발점을 검사하여 바닥까지 가장 짧은 이동 거리를 갖는 시작점 x(복수 개인 경우 가장 큰 x좌표)를 반환하는 코드를 작성하라.(‘0’으로 채워진 평면상에 사다리는 연속된 ‘1’로 표현된다.)

<그림 1> 사다리 게임에 대한 설명(미니맵)



최단거리로 바닥에 도착하려면 X=4인 출발점에서 출발해야 하므로 답은 4가 된다. 해당 경로는 별도로 표시하였다.

방향 전환 이후엔 다시 아래 방향으로만 이동하게 되며, 바닥에 도착하면 멈추게 된다.

X=0인 출발점에서 출발하는 사례에 대해서 화살표로 표시한 바와 같이, 아래 방향으로 진행하면서 좌우 방향으로 이동 가능한 통로가 나타나면 방향 전환을 하게 된다.

아래 <그림 1>의 예를 살펴보면, 출발점 x=0 및 x=9인 세로 방향의 두 막대 사이에 임의의 개수의 막대들이 랜덤 간격으로 추가되고(이 예에서는 2개가 추가됨) 이 막대들 사이에 가로 방향의 선들이 또한 랜덤하게 연결된다.

사다리를 다 그리고 보니 김 대리는 어느 사다리를 고르면 최단거리로 바닥에 도착하게 되는지 궁금해졌다. 이를 구해보자.

김 대리는 사다리타기에 참여하지 않는 대신 사다리를 그리기로 하였다.

점심 시간에 산책을 다니는 사원들은 최근 날씨가 더워져, 사다리 게임을 통하여 누가 아이스크림을 구입할지 결정하기로 한다.
'''
import sys
sys.stdin = open('ladder2.txt')
for tc in range(1, 11): # 총 10개의 테스트 케이스
    T = int(input()) # 테스트 케이스 번호 저장
    lst = [[0] + list(map(int, input().split())) + [0] for _ in range(100)] # 사다리에 양 옆 0인 줄 추가하여 lst에 저장
    # [0] + list(map(int, input().split()) + [0] 가로줄을 100번 반복
    # 가로줄 102개 세로줄 100개
    # 바닥까지 짧은 이동 거리를 갖는 시작점 x를 반환
    # 첫 줄을 돌면서 1인것 == 시작점인것 찾고 칸수를 세면서 내려가기
    # 델타탐색 사용
    st = [] # 시작점 모은 리스트
    dj = [1, 0, -1] # 오른쪽 아래 왼쪽 탐색
    for k in range(1, 101): # x 좌표 1부터 100까지임
        if lst[0][k] == 1: # 시작점이면
            st.append(k)
    print(st)
    min_cnt = 100*100 # 최솟값 비교 위해 필요, 100*100에서 나올 수 있는 최대 카운트
    min_st = 0 # 시작점 저장할 변수
    for i in st:
        x, y = i, 0
        cnt = 0
        while y <= 99:
            if lst[y][x+1] == 0 and lst[y][x-1] == 0: # 좌우가 0일때
                y += 1
                cnt += 1
            elif lst[y][x+1] == 1: # 오른쪽이 1일때
                while lst[y][x+1] == 1: # 1이 안나올때까지
                    x += 1
                    cnt += 1
                y += 1 # 끝까지 간 다음 한칸 내려감
                cnt += 1
            elif lst[y][x-1] == 1:
                while lst[y][x-1] == 1:
                    x -= 1
                    cnt += 1
                y += 1
                cnt += 1
        if min_cnt >= cnt: # 최솟값 비교
            min_st, min_cnt = i, cnt
    print(f'#{T} {min_st-1}') # 원래 좌표로 변환해야하니까 -1
