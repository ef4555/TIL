
'''
N x N 배열 안의 숫자는 해당 영역에 존재하는 파리의 개수를 의미한다.

아래는 N=5 의 예이다.
 
M x M 크기의 파리채를 한 번 내리쳐 최대한 많은 파리를 죽이고자 한다.

죽은 파리의 개수를 구하라!

예를 들어 M=2 일 경우 위 예제의 정답은 49마리가 된다.
 
[제약 사항]

1. N 은 5 이상 15 이하이다.

2. M은 2 이상 N 이하이다.

3. 각 영역의 파리 갯수는 30 이하 이다.

[입력]

가장 첫 줄에는 테스트 케이스의 개수 T가 주어지고, 그 아래로 각 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에 N 과 M 이 주어지고,

다음 N 줄에 걸쳐 N x N 배열이 주어진다.

[출력]

출력의 각 줄은 '#t'로 시작하고, 공백을 한 칸 둔 다음 정답을 출력한다.

(t는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)

'''
# 델타 탐색의 확장확장
import sys
sys.stdin = open('catch_pari.txt')
T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())
    lst = [[0]*N for _ in range(N)] # 리스트로 받아서 한줄씩 넣음
    for q in range(N):
        lst[q] = list(map(int, input().split()))

    c_hap = [] # 합을 담을 리스트
    for i in range(N-M+1):
        for j in range(N-M+1): # 좌표가 옮겨질때마다 파리를 새롭게 잡는것(범위 변경됨)
            h = 0
            c = [] # 지정된 칸수에 파리 수 저장할 리스트
            for k in range(M):
                for l in range(M):
                    c.append(lst[i+k][j+l]) # 파리 잡은 점들 집합에 넣어줌
            for pp in c:
                h += pp
            c_hap.append(h)

    # print(c_hap)
    max_hap = 0
    for h in c_hap:
        if max_hap <= h:
            max_hap = h
    print(f'#{tc} {max_hap}')

'''
삽질 포인트
1. 처음에 주변 칸을 모두 합해야 한다는 조건을 보고 델타 탐색을 떠올림. 그러나 델타탐색은 크기가 확장되면 복잡해진다
문제에서 조사 범위의 크기가 가변적이므로 델타탐색은 적합하지 않다 여기서 시간 많이 소요
그리고 생각해보니 여기는 정확히 M*M 범위만 탐색하므로 끝자리 생각 안해도 되니까 델타탐색 안해도 된다. 

2. 저번에 페인팅 문제가 떠오름. 처음 점과 끝 점이 주어지면 한줄씩 칠해간다는 느낌으로 좌표를 옮기면서 범위 탐색 가능
    - 그런데 어떻게 좌표 세팅을 할 것인가?
    - 일단 좌표 + M-1까지 탐색하게 된다.
    - 그러면 원래 좌표의 범위는 (N-M+1)이어야 (좌표+M-1)까지 탐색했을때 원래처럼 range(N)의 범위이다.
    - 범위 조정에 시간 많이 걸렸다. for 문 네 번 중첩, 원래 좌표를 옮기면서 범위를 탐색을 한다.
    - 리셋 범위가 어디인지? 어디에 데이터를 담을 리스트를 넣어야 하는지?
    
3. 델타 탐색의 범위가 점점 커지게 하려면 어떻게 해야할까?
    - dj에 for문 써서 점점 곱해주면 될 듯?
    
     
'''

'''
# 9칸 델타탐색 
di = [0,-1,-1,-1,0,1,1,1,0]
dj = [0,-1,0,1,1,1,0,-1,-1]
hap = 0
for i in range(N):
    for j in range(N):
        c = []
        for k in range(9):
            if 0 <= i+di[k] < N and 0 <= j+dj[k] < N :
                c.append(lst[i+di[k]][j+dj[k]])
        print(c)  
'''


